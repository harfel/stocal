+ process.trajectory
- modified StochasticSimulationAlgorithm.__iter__ protocol
- add public API documentation
- regroup tests into specifications, unittests and bugs
- reorganize stocal/tests/test_examples.py
- test for memory leaks
- update copyright, version etc.
- run full validation
= release/2.0
* stocal.algorithms.AndersonMethod.update_state is broken
* Sampler seed does not guarantee identical trajectory on subsequent runs

+ support for proper delay events
- lazy and persistent trajectories
- arithmetic operations for Process
- string rewrite rule support
- other kinetic laws, e.g. Hill function
- libSBML integration
- curried reactions (determine products only upon application)
- performance measurements and profiling
- C/C++/D implementation
= version 2.1+
= version 3

Tests
-----
tests/
  +-- bugs/
  +-- examples/
  +-- unittests/
  +-- api
  +-- tutorial

Trajectory
----------
A trajectory is a "bundle" of discrete axes that correspond to individual species counts. All these
axes share the same associated time axis. (This should facilitate axes arithmetics for statistics).
The time axis can be continuous (as generated by exact Gillespie sampling) or discrete (for example
at given time points).

At the same time, I want Samplers to become persistent, so Sampler.__iter__ should probably not be
a generator function. Instead, I could implement the normal iterator protocol via __iter__ and
__next__.

    Sampler.__next__()            advance one step
    Sampler.until(time, steps=0)  advance to time
    Sampler.steps(n)              perform n steps

Does Sampler need to know steps?
for trans in Sampler(proc, state, steps=n):
    pass
-->
sample = Sampler(proc, state)
for step in range(n):
    transition = next(sample)
    pass


Simulation engine
-----------------
All number crunching should be done lazy and potentially in another
task/process. Samplers should be able to be stoped, resumed, loaded
and saved.
